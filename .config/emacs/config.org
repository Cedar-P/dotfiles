#+TITLE: My Emacs Config, No Longer Bankrupt
#+AUTHOR: bugger
#+PROPERTY: header-args :tangle init.el
#+OPTIONS: toc:2
#+auto_tangle: t

* Table of contents :toc:
- [[#package-setup][Package setup]]
  - [[#melpa][Melpa]]
  - [[#use-package][use-package]]
- [[#evil][Evil]]
- [[#ux][UX]]
  - [[#fonts][Fonts]]
  - [[#indent-guides][Indent guides]]
  - [[#theme][Theme]]
  - [[#modeline][Modeline]]
  - [[#centaur-tabs][Centaur tabs]]
  - [[#line-numbers][Line numbers]]
  - [[#highlight-the-line][Highlight the line]]
  - [[#rid-of-ugly-stuff][Rid of ugly stuff]]
  - [[#scrolling][Scrolling]]
  - [[#dashboard][Dashboard]]
  - [[#rainbows][Rainbows!]]
  - [[#window-transparency][Window transparency]]
  - [[#tree-sitter][Tree Sitter]]
- [[#org-mode][Org mode]]
  - [[#org-tempo][Org tempo]]
  - [[#auto-tangle][Auto tangle]]
  - [[#indentation][Indentation]]
  - [[#toc-org][Toc-org]]
  - [[#babel-settings][Babel settings]]
  - [[#org-agenda][Org agenda]]
- [[#nice-packages][Nice Packages]]
  - [[#smartparens][Smartparens]]
  - [[#ivy][Ivy]]
  - [[#tabbing][Tabbing]]
  - [[#visual-lines][Visual lines]]
  - [[#too-lazy-to-type-yes][Too lazy to type yes]]
  - [[#too-lazy-to-type-esc-esc-esc-or-c-g][Too lazy to type ESC-ESC-ESC or C-g]]
  - [[#autocompletion][Autocompletion]]
  - [[#flycheck][Flycheck]]
  - [[#vterm][Vterm]]
  - [[#treemacs][Treemacs]]
  - [[#projectile][Projectile]]
  - [[#undo][Undo]]
  - [[#yasnippet][YASnippet]]
  - [[#web-mode][Web mode]]
  - [[#commenting][Commenting]]
  - [[#dired][Dired]]
- [[#keybindings][Keybindings]]
  - [[#general][General]]
  - [[#which-key][Which-key]]
  - [[#nice-little-things][Nice little things]]
  - [[#files][Files]]
  - [[#windows][Windows]]
  - [[#buffers][Buffers]]
  - [[#ibuffer][Ibuffer]]
  - [[#dired-1][Dired]]
  - [[#dashboard-1][Dashboard]]
  - [[#org-agenda-1][Org agenda]]
  - [[#magit][Magit]]
  - [[#helpful-functions][Helpful functions]]
  - [[#toggle][Toggle]]
  - [[#projectile-1][Projectile]]
  - [[#yasnippet-1][YASnippet]]
- [[#clean-up][Clean up]]

* Package setup
** Melpa
Melpa is a repository for emacs that enables a lot more than what is in the standard elpa repos
#+begin_src emacs-lisp
  (require 'package)
  (setq package-user-dir "~/.config/emacs/.local/elpa")
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (package-initialize)
#+end_src

** use-package
This is no longer needed, since Emacs 29 has use-package built in
#+begin_src emacs-lisp
  ;(unless (package-installed-p 'use-package)
    ;(package-refresh-contents)
    ;(package-install 'use-package))
  ;(setq use-package-always-ensure t)
#+end_src

* Evil
Evil is a vim emulation package for emacs, the Emacs Vi extension Layer
#+begin_src emacs-lisp
(use-package evil
  :ensure t
  :init
  (setq evil-want-keybinding nil)
  :config
  (evil-mode 1)
  (setq evil-undo-system 'undo-redo))
#+end_src

add evil in every buffer
#+begin_src emacs-lisp
(use-package evil-collection
  :after evil magit
  :config
  (setq evil-collection-mode-list '(dashboard))
  (evil-collection-init))
#+end_src

* UX
** Fonts
#+begin_src emacs-lisp
(add-to-list 'default-frame-alist
             '(font . "AnonymicePro Nerd Font Mono-15"))
(use-package treemacs-icons-dired
  :ensure t
  :hook (dired-mode . treemacs-icons-dired-mode))
#+end_src

** Indent guides
#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :defer t
  :ensure t
  :hook (prog-mode . highlight-indent-guides-mode))
(add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
(setq highlight-indent-guides-method 'character)
#+end_src

** Theme
#+begin_src emacs-lisp
(use-package doom-themes
  :ensure t
  :config (load-theme 'doom-one t))
#+end_src

** Modeline
A nice little bar at the bottom
#+begin_src emacs-lisp
(use-package doom-modeline
  :ensure t
  :hook (after-init . doom-modeline-mode)
  :hook (doom-modeline-mode . size-indication-mode)
  :hook (doom-modeline-mode . column-number-mode)

  :init
  (setq projectile-dynamic-mode-line t)

  ;; Set these early so they don't trigger variable watchers
  (setq doom-modeline-bar-width 3
        doom-modeline-github nil
        doom-modeline-mu4e nil
        doom-modeline-persp-name nil
        doom-modeline-minor-modes nil
        doom-modeline-major-mode-icon nil
        doom-modeline-buffer-file-name-style 'relative-from-project
        ;; Only show file encoding if it's non-UTF-8 and different line endings
        ;; than the current OSes preference
        doom-modeline-buffer-encoding 'nondefault
        doom-modeline-default-eol-type 0
        doom-modeline-height 35)
  (when (daemonp)
    (setq doom-modeline-icon t))
  :config
  
  (add-hook 'ef-themes-post-load-hook #'doom-modeline-refresh-bars))
#+end_src

** Centaur tabs
Centaur tabs is a better tab bar for emacs
#+begin_src emacs-lisp
(use-package centaur-tabs
  :hook (server-after-make-frame . centaur-tabs-mode)
  :init
  (setq centaur-tabs-set-icons t
        centaur-tabs-gray-out-icons 'buffer
        centaur-tabs-set-bar 'left
        centaur-tabs-set-modified-marker t
        centaur-tabs-close-button "✕"
        centaur-tabs-modified-marker "•"
        ;; Scrolling (with the mouse wheel) past the end of the tab list
        ;; replaces the tab list with that of another Doom workspace. This
        ;; prevents that.
        centaur-tabs-cycle-scope 'tabs))

  ;; When started in daemon mode, centaur tabs does not work at all, so here is a fix
  (if (not (daemonp))
      (centaur-tabs-mode)

    (defun centaur-tabs--daemon-mode (frame)
      (unless (and (featurep 'centaur-tabs) (centaur-tabs-mode-on-p))
        (run-at-time nil nil (lambda () (centaur-tabs-mode)))))
    (add-hook 'after-make-frame-functions #'centaur-tabs--daemon-mode))
#+end_src
    
** Line numbers
#+begin_src emacs-lisp
(global-display-line-numbers-mode 1)
(with-eval-after-load "dashboard"
  (add-hook 'dashboard-mode-hook #'(lambda () (interactive) (display-line-numbers-mode -1))))
#+end_src

** Highlight the line
#+begin_src emacs-lisp
(global-hl-line-mode)
#+end_src

** Rid of ugly stuff
#+begin_src emacs-lisp
(tool-bar-mode -1)
(scroll-bar-mode -1)
(menu-bar-mode -1)
#+end_src

** Scrolling
#+begin_src emacs-lisp
;; scroll one line at a time (less "jumpy" than defaults)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; 2 lines at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
(setq scroll-step 1) ;; keyboard scroll one line at a time
(setq scroll-conservatively 101) ;; scroll one line at a time when moving the cursor down the page
(pixel-scroll-precision-mode 1) ;; smooth scrolling
#+end_src

** Dashboard
All the icons gives icons in the dashboard
#+begin_src emacs-lisp
(use-package all-the-icons
  :if (display-graphic-p))
#+end_src

Nice little lines
#+begin_src emacs-lisp
(use-package page-break-lines
  :config (global-page-break-lines-mode))
#+end_src

Get rid of agenda files from the recentf list
#+begin_src emacs-lisp
(use-package recentf
  :config
  (add-to-list 'recentf-exclude "~/org/agenda/schedule.org")
  (add-to-list 'recentf-exclude "~/org/agenda/todo.org")
  (add-to-list 'recentf-exclude "~/org/agenda/emacs.org")
  (add-to-list 'recentf-exclude "~/org/agenda/homework.org")
  (add-to-list 'recentf-exclude "~/.config/emacs/bookmarks"))
#+end_src

*** The actual dashboard
A dashboard inside of emacs
#+begin_src emacs-lisp
(use-package dashboard
  :after all-the-icons
  :after page-break-lines
  :after projectile
  :after recentf
  :ensure t
  :init
  (setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
  (setq dashboard-items '((recents . 5)
                          (projects . 5)
                          (agenda . 5)))
  (setq dashboard-icon-type 'all-the-icons)
  (setq dashboard-center-content t)
  (setq dashboard-set-heading-icons t)
  (setq dashboard-set-file-icons t)
  :config
  (dashboard-setup-startup-hook))
#+end_src

** Rainbows!
Adds rainbow parentheses and color to hex values and such
#+begin_src emacs-lisp
(use-package rainbow-mode
  :hook (prog-mode . (lambda () (interactive) (rainbow-mode 1))))
(use-package rainbow-delimiters
  :hook (prog-mode . (lambda () (interactive) (rainbow-delimiters-mode 1))))
(use-package rainbow-identifiers
  :hook (prog-mode . (lambda () (interactive) (rainbow-identifiers-mode 1))))
#+end_src

** Window transparency
Another new feature in Emacs 29 that lets you make the background transparent while keeping text and such solid
#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(alpha-background . 85))
#+end_src

** Tree Sitter
Tree sitter is now built into emacs as of Emacs 29
#+begin_src emacs-lisp
(add-hook 'java-mode-hook 'java-ts-mode)
#+end_src
* Org mode
Org mode is an extremely helpful tool that allows you to do anything from writing scientific papers, take notes, even write entire programs!
** Org tempo
A simple tool that simplifies writing source code blocks to just typing <s TAB, as well as other similar functions
#+begin_src emacs-lisp
(use-package org-tempo
  :ensure nil)
#+end_src

** Auto tangle
Tangle a file to its source code blocks automatically upon save
#+begin_src emacs-lisp
(use-package org-auto-tangle
  :ensure t
  :defer t
  :hook (org-mode . org-auto-tangle-mode))
#+end_src

** Indentation
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'org-indent-mode)
(setq org-hide-leading-stars nil)
#+end_src

** Toc-org
This automatically generates a table of contents under any heading tagged :TOC:
#+begin_src emacs-lisp
(use-package toc-org
  :hook (org-mode . toc-org-mode))
#+end_src
** Babel settings
#+begin_src emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-confirm-babel-evaluate nil
      org-src-window-setup 'current-window
      org-src-preserve-indentation t)
#+end_src

** Org agenda
Org agenda is a full blown scheduling application with all the power of org mode built into it
#+begin_src emacs-lisp
(setq org-agenda-files (list "~/org/agenda/todo.org"
                             "~/org/agenda/homework.org"
                             "~/org/agenda/emacs.org"
                             "~/org/agenda/schedule.org"))

;; a better org agenda interface
(use-package calfw)
(use-package calfw-org :after calfw)
#+end_src

* Nice Packages
Things that aren't really necessary to do stuff, but nice to have
** Smartparens
Auto completes (, [, {, ", etc for you so you don't have to keep track of them
#+begin_src emacs-lisp
(use-package smartparens
  :config
  (require 'smartparens-config)
  (smartparens-global-mode 1))
#+end_src

** Ivy
Ivy is a minibuffer autocompletion framework that makes it a lot easier to do things like input commands
*** Just ivy
#+begin_src emacs-lisp
(use-package ivy
  :defer 0.1
  :diminish
  :custom
  (setq ivy-count-format "(%d/%d) ")
  (setq ivy-use-virtual-buffers t)
  (setq enable-recursive-minibuffers t)
  :config
  (ivy-mode))
#+end_src

*** Counsel
Counsel a sort of extension to ivy, taking lots of functions already in emacs and putting them into an ivy completion minibuffer
#+begin_src emacs-lisp
(use-package counsel
  :after ivy
  :defer t
  :config
  (counsel-mode)
  (setq ivy-initial-inputs-alist nil)) ; Disable the "^" in interactive counsel commands like M-x
#+end_src

*** Ivy-rich
Gives us keybindings alongside the commands they go with when in an ivy completion minibuffer
#+begin_src emacs-lisp
(use-package ivy-rich
  :after ivy
  :defer t
  :custom
  (ivy-virtual-abbreviate 'full
   ivy-rich-switch-buffer-align-virtual-buffer t
   ivy-rich-path-style 'abbrev)
  :config
  (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
  (ivy-rich-mode 1))
#+end_src

*** Swiper
A better way to search
#+begin_src emacs-lisp
(use-package swiper
  :after ivy
  :defer t
  :bind (:map evil-normal-state-map
         ("/" . swiper-isearch)
         ("n" . evil-search-previous)
         ("N" . evil-search-next)))
#+end_src

** Tabbing
#+begin_src emacs-lisp
(setq indent-tabs-mode t)
(setq-default tab-width 4
              c-basic-offset 4
              c-default-style "stroustrup")
(defvaralias 'c-basic-offset 'tab-width)
#+end_src

** Visual lines
#+begin_src emacs-lisp
(define-key evil-normal-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
(define-key evil-normal-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
(define-key evil-motion-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
(define-key evil-motion-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
#+end_src

** Too lazy to type yes
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

** Too lazy to type ESC-ESC-ESC or C-g
#+begin_src emacs-lisp
(global-set-key (kbd "<escape>") 'abort-minibuffers)
#+end_src

** Autocompletion
Emacs has support for code autocompletion on par with that of IDEs like VSCode or IntelliJ
*** Company
Company is the package that enables the little popup for autocompletion so you don't to invoke a keybind or anything
#+begin_src emacs-lisp
(use-package company
  :defer t
  :ensure t
  :config
  (global-company-mode))
#+end_src
*** LSP
LSP is the Language Server Protocol, and is what actually populates the company frame with suggestions
#+begin_src emacs-lisp
(use-package lsp-mode
  :defer t
  :hook (prog-mode . #'lsp-deferred)
  :config
  (setq lsp-keymap-prefix "C-l"))

; extensions
(use-package lsp-haskell
  :defer t
  :after lsp-mode)
(use-package lsp-treemacs
  :defer t
  :after lsp-mode)
(use-package lsp-java
  :defer t
  :after lsp-mode)
(use-package lsp-ui
  :defer t
  :after lsp-mode
  :hook (lsp-mode . lsp-ui-doc-mode))
#+end_src

** Flycheck
Flycheck is a program that enables essentially 'spell checking' your code
#+begin_src emacs-lisp
(use-package flycheck
  :defer t
  :config
  (global-flycheck-mode))
#+end_src
** Vterm
Vterm is a fully fledged terminal within emacs
#+begin_src emacs-lisp
(use-package vterm
  :defer t
  :ensure t
  :config
  (setq shell-file-name "/bin/zsh"
		vterm-max-scrollback 5000))
#+end_src
*** Toggling
It's kind of annoying to have an ordinary window stuck there at the bottom that you have to deal with and pop back up to reconfigure the window again, so why not add a toggle for it?
#+begin_src emacs-lisp
(use-package vterm-toggle
  :after vterm
  :ensure t
  :config
  (setq vterm-toggle-fullscreen-p nil)
  (setq vterm-toggle-scope 'project)
  (add-to-list 'display-buffer-alist
               '((lambda (buffer-or-name _)
                     (let ((buffer (get-buffer buffer-or-name)))
                       (with-current-buffer buffer
                         (or (equal major-mode 'vterm-mode)
                             (string-prefix-p vterm-buffer-name (buffer-name buffer))))))
                  (display-buffer-reuse-window display-buffer-at-bottom)
                  ;;(display-buffer-reuse-window display-buffer-in-direction)
                  ;;display-buffer-in-direction/direction/dedicated is added in emacs27
                  ;;(direction . bottom)
                  ;;(dedicated . t) ;dedicated is supported in emacs27
                  (reusable-frames . visible)
                  (window-height . 0.3))))
#+end_src
** Treemacs
Treemacs is a little side panel that shows a directory tree
#+begin_src emacs-lisp
(use-package treemacs :defer t)
(use-package treemacs-evil :after (treemacs evil))
(use-package treemacs-projectile :after (treemacs projectile))
(use-package treemacs-magit :after (treemacs magit))
(use-package treemacs-all-the-icons :after treemacs)
#+end_src
** Projectile
Projectile manages projects
#+begin_src emacs-lisp
(use-package projectile
  :config
  (projectile-mode +1))
(use-package projectile-ripgrep :after projectile)
(use-package counsel-projectile :after (projectile counsel))
#+end_src

** Undo
** YASnippet
YASnippet is a templating system for emacs that allows you to type whatever you want, that expands into whatever you want.
*** Main Install
#+begin_src emacs-lisp
(use-package yasnippet
  :ensure t
  :config
  (setq yas-snippet-dirs '("~/.config/emacs/snippets"))
  (yas-global-mode 1))
#+end_src

*** Extra Snippets
#+begin_src emacs-lisp
(use-package yasnippet-snippets :ensure t :after yasnippet)
(use-package java-snippets :ensure t :after yasnippet)
#+end_src
** Web mode
Support for web development with web-mode and emmet-mode
#+begin_src emacs-lisp
(use-package web-mode
  :ensure t
  :init
  (add-to-list 'auto-mode-alist  '("\\.html$" . web-mode))
  (add-to-list 'auto-mode-alist  '("\\.css?\\'" . web-mode))
  (add-to-list 'auto-mode-alist  '("\\.js$\\'" . web-mode)))
(use-package emmet-mode
  :ensure t
  :after web-mode
  :hook (web-mode . emmet-mode))
#+end_src

** Commenting
Neat package that gives some nice commenting functions
#+begin_src emacs-lisp
(use-package evil-nerd-commenter :ensure t)
#+end_src
** Dired
Dired has some nice extensions that let you automatically open in another program, and preview files
#+begin_src emacs-lisp
(use-package dired-open
  :ensure t
  :after dired
  :config
  (setq dired-open-extensions '(("gif" . "nsxiv")
								("jpg" . "nsxiv")
								("png" . "nsxiv")
								("mkv" . "mpv")
								("mp4" . "mpv")
								("mp3" . "mpv"))))
(use-package peep-dired
  :after dired
  :ensure t
  :hook (peep-dired . evil-normalize-keymaps)
  :config
  (evil-define-key 'normal dired-mode-map (kbd "h") 'dired-up-directory)
  (evil-define-key 'normal dired-mode-map (kbd "j") 'peep-dired-next-file)
  (evil-define-key 'normal peep-dired-mode-map (kbd "k") 'peep-dired-prev-file)
  (evil-define-key 'normal peep-dired-mode-map (kbd "l") 'dired-open-file))


#+end_src
* Keybindings
** General
General is a package that allows us to do very complex things like bind space as a leader key, or add which-key labels to prefix keys
#+begin_src emacs-lisp
  (use-package general
    :ensure t
    :init (general-evil-setup t))
#+end_src

** Which-key
Which-key displays possible completions for keybindings you have typed in a minibuffer at the bottom of the screen
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :config (which-key-mode 1))
#+end_src

#+begin_src emacs-lisp
(setq evil-undo-system 'undo-redo)
#+end_src
** Nice little things
#+begin_src emacs-lisp
;; tab over the region
(general-define-key
 :states 'visual
 "TAB" (lambda ()
         (interactive)
         (tab-to-tab-stop)))

;; comment/uncomment the region
(general-define-key
 :states '(normal visual)
 "C-/" '(evilnc-comment-or-uncomment-lines :which-key "Comment lines"))

;; toggle tolding
(general-define-key
 :states 'normal
 "TAB" 'evil-toggle-fold)

;; delete a tab, not 4 spaces
(global-set-key (kbd "DEL") 'backward-delete-char)
(setq c-backspace-function 'backward-delete-char)

;; Better directory navigation in ivy
(eval-after-load 'ivy #'(lambda ()
						  (define-key ivy-mode-map (kbd "DEL") 'ivy-backward-delete-char)))
#+end_src

** Files
#+begin_src emacs-lisp
  (general-define-key
   :states '(normal visual)
   :prefix "SPC"
   "f"   '(:ignore t :which-key "files")
   "f s" '(save-buffer :which-key "Save file")
   "."   '(find-file   :which-key "open file"))
#+end_src

** Windows
#+begin_src emacs-lisp
  (general-define-key
   :states '(normal visual)
   :prefix "SPC"
   "w"   '(:ignore t              :which-key "windows")
   "w w" '(evil-window-next       :which-key "next window")
   "w v" '(evil-window-vsplit     :which-key "create new vertical window")
   "w n" '(evil-window-new        :which-key "create new window")
   "w q" '(evil-window-delete     :which-key "delete current window")
   "w k" '(kill-buffer-and-window :which-key "delete current window and buffer"))
#+end_src

** Buffers
#+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "b"   '(:ignore t                 :which-key "buffer")
 "b b" '(buffer-menu               :which-key "buffer menu")
 "b i" '(ibuffer                   :which-key "ibuffer")
 "b c" '(kill-this-buffer          :which-key "kill buffer")
 "b k" '(kill-this-buffer          :which-key "kill buffer")
 "b p" '(previous-buffer           :which-key "previous buffer")
 "b n" '(next-buffer               :which-key "next buffer")
 "b h" '(centaur-tabs-backward-tab :which-key "previous tab")
 "b l" '(centaur-tabs-forward-tab  :which-key "previous tab")
 "b r" '(revert-buffer             :which-key "reload buffer"))
(define-key evil-normal-state-map (kbd "q") #'(lambda ()
                                                (interactive)
                                                (when (buffer-modified-p)
                                                  (when (y-or-n-p "Buffer modified. Save?")
                                                    (save-buffer)))
                                                (kill-this-buffer)))
(define-key evil-normal-state-map (kbd "Q") #'(lambda ()
                                                (interactive)
                                                (when (buffer-modified-p)
                                                  (when (y-or-n-p "Buffer modified. Save?")
                                                    (save-buffer)))
                                                (kill-buffer-and-window)))
#+end_src

** Ibuffer
Add evil keybindings
#+begin_src emacs-lisp
(add-hook 'ibuffer-mode-hook #'(lambda ()
								 (interactive)
								 (keymap-local-set (kbd "l") 'ibuffer-visit-buffer)
								 (keymap-local-set (kbd "j") 'evil-next-visual-line)
								 (keymap-local-set (kbd "k") 'evil-previous-visual-line)))
#+end_src

** Dired
#+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "d" '(:ignore t :which-key "dired")
 "d d" '(dired :which-key "open dired")
 "d p" '(peep-dired :which-key "toggle peep-dired")
 "d j" '(dired-jump :which-key "open dired at current directory"))
(with-eval-after-load 'dired
  (evil-define-key 'normal dired-mode-map (kbd "h") 'dired-up-directory)
  (evil-define-key 'normal dired-mode-map (kbd "l") 'dired-open-file)) ; use dired-find-file if not using dired-open package
#+end_src

** Dashboard
#+begin_src emacs-lisp
(with-eval-after-load "evil"
  (add-hook 'dashboard-mode-hook #'(lambda ()
                                   (interactive)
                                   (evil-local-set-key 'normal (kbd "r") 'dashboard-jump-to-recents)
                                   (evil-local-set-key 'normal (kbd "p") 'dashboard-jump-to-projects)
                                   (evil-local-set-key 'normal (kbd "a") 'dashboard-jump-to-agenda)
                                   (evil-local-set-key 'normal (kbd "l") 'dashboard-return)
                                   (evil-local-set-key 'normal (kbd "e") #'(lambda ()
                                                                             (interactive)
                                                                             (find-file "~/.config/emacs/config.org")))
                                   (evil-local-set-key 'normal (kbd "x") #'(lambda ()
                                                                             (interactive)
                                                                             (find-file "~/.config/xmonad/xmonad.org"))))))
#+end_src

** Org agenda
#+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "o"     '(:ignore t :which-key "org")
 "o a"   '(:ignore t :which-key "org agenda")
 "o a c" '(cfw:open-org-calendar :which-key "open org calendar")
 "o C"   '(cfw:open-org-calendar :which-key "open org calendar")
 "o a a" '(org-agenda :which-key "open org agenda")
 "o a t" '(org-agenda-todo :which-key "open todo list"))
#+end_src

** Magit
#+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "g"   '(:ignore t :which-key "magit")
 "g g" '(magit :which-key "open magit")
 "g s" '(magit-status :which-key "status")
 "g b" '(magit-branch :which-key "branch")
 "g c o" '(magit-checkout :which-key "checkout")
 "g c b" '(magit-branch-and-checkout :which-key "create and checkout a branch")
 "g c c" '(magit-commit :which-key "commit")
 "g p l" '(magit-pull :which-key "pull")
 "g p s" '(magit-push :which-key "push"))
#+end_src

** Helpful functions
#+begin_src emacs-lisp
(defun bugger/reload ()
  (interactive)
  (org-babel-tangle-file "~/.config/emacs/config.org")
  (load-file "~/.config/emacs/init.el")
  (load-file "~/.config/emacs/init.el"))

(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "h" '(:ignore t :which-key "help")
 "h r" '(:ignore t :which-key "reload")
 "h r r" '(bugger/reload :which-key "reload emacs")
 "h v" '(describe-variable :which-key "describe variable")
 "h t" '(counsel-load-theme :which-key "load theme")
 "h f" '(describe-function :which-key "describe function"))
#+end_src

** Toggle
#+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "t" '(:ignore t :which-key "toggle")
 "t v" '(vterm-toggle :which-key "open vterm"))
#+end_src

** Projectile
#+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "/" '(counsel-projectile-rg :which-key "search project")
 "p" '(:ignore t :which-key "projectile")
 "p p" '(counsel-projectile :which-key "open project")
 "p c" '(projectile-compile-project :which-key "compile project")
 "p f" '(counsel-projectile-find-file-dwim :which-key "find file"))
#+end_src

** YASnippet
#+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "i" '(:ignore t :which-key "insert")
 "i s" '(yas-insert-snippet :which-key "snippets"))
(general-define-key
 :states 'insert
 :prefix "M-SPC"
 "i" '(:ignore t :which-key "insert")
 "i s" '(yas-insert-snippet :which-key "snippets"))
#+end_src
* Clean up
Just need to put gc-cons-threshold back to a normal figure after init
#+begin_src emacs-lisp
(setq gc-cons-threshold (* 2 1024 1024))
#+end_src

