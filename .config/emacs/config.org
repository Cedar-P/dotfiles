#+TITLE: My Emacs Config, No Longer Bankrupt
#+AUTHOR: bugger
#+PROPERTY: header-args :tangle init.el
#+OPTIONS: toc:2
#+auto_tangle: t

* Table of contents :toc:
- [[#early-settings][Early Settings]]
  - [[#variables-for-later][Variables for later]]
  - [[#mouse-control-for-buffers][Mouse control for buffers]]
  - [[#make-emacsd-clean-again][Make .emacs.d clean again!]]
  - [[#package-choices][Package choices]]
- [[#package-setup][Package setup]]
  - [[#melpa][Melpa]]
  - [[#use-package][use-package]]
  - [[#custom-package-management][Custom Package Management]]
- [[#evil][Evil]]
- [[#ux][UX]]
  - [[#fonts][Fonts]]
  - [[#indent-guides][Indent guides]]
  - [[#theme][Theme]]
  - [[#icons][Icons]]
  - [[#modeline][Modeline]]
  - [[#centaur-tabs][Centaur tabs]]
  - [[#line-numbers][Line numbers]]
  - [[#highlight-the-line][Highlight the line]]
  - [[#rid-of-ugly-stuff][Rid of ugly stuff]]
  - [[#scrolling][Scrolling]]
  - [[#dashboard][Dashboard]]
  - [[#rainbows][Rainbows!]]
  - [[#window-transparency][Window transparency]]
  - [[#tree-sitter][Tree Sitter]]
  - [[#visual-line-mode][Visual Line Mode]]
- [[#org-mode][Org mode]]
  - [[#org-tempo][Org tempo]]
  - [[#auto-tangle][Auto tangle]]
  - [[#indentation][Indentation]]
  - [[#toc-org][Toc-org]]
  - [[#babel-settings][Babel settings]]
  - [[#org-agenda][Org agenda]]
- [[#nice-packages-and-settings][Nice Packages and Settings]]
  - [[#keeping-emacs-clean][Keeping emacs clean]]
  - [[#smartparens][Smartparens]]
  - [[#ivy][Ivy]]
  - [[#tabbing][Tabbing]]
  - [[#visual-lines][Visual lines]]
  - [[#too-lazy-to-type-yes][Too lazy to type yes]]
  - [[#too-lazy-to-type-esc-esc-esc-or-c-g][Too lazy to type ESC-ESC-ESC or C-g]]
  - [[#autocompletion][Autocompletion]]
  - [[#flycheck][Flycheck]]
  - [[#treemacs][Treemacs]]
  - [[#projectile][Projectile]]
  - [[#perspectives][Perspectives]]
  - [[#yasnippet][YASnippet]]
  - [[#web-mode][Web mode]]
  - [[#commenting][Commenting]]
  - [[#dired][Dired]]
  - [[#auto-backup][Auto Backup]]
  - [[#undo][Undo]]
- [[#emacs-as-an-operating-system][Emacs as an Operating System]]
  - [[#app-launcher][App Launcher]]
  - [[#exwm][EXWM]]
  - [[#elfeed][Elfeed]]
  - [[#vterm][Vterm]]
  - [[#emms][EMMS]]
  - [[#calfw][Calfw]]
  - [[#mu4e][MU4E]]
  - [[#password-encryption][Password Encryption]]
- [[#keybindings][Keybindings]]
  - [[#nice-little-things][Nice little things]]
  - [[#general][General]]
  - [[#which-key][Which-key]]
  - [[#files][Files]]
  - [[#windows][Windows]]
  - [[#buffers][Buffers]]
  - [[#ibuffer][Ibuffer]]
  - [[#dired-1][Dired]]
  - [[#dashboard-1][Dashboard]]
  - [[#org-agenda-1][Org agenda]]
  - [[#magit][Magit]]
  - [[#helpful-functions][Helpful functions]]
  - [[#toggle][Toggle]]
  - [[#reload][Reload]]
  - [[#projectile-1][Projectile]]
  - [[#yasnippet-1][YASnippet]]
  - [[#emms-1][EMMS]]
  - [[#perspective][Perspective]]
- [[#clean-up][Clean up]]

* Early Settings
Some stuff that has to get set pretty early, lest the rest of the config get messed up
** Variables for later
Some things shouldn't be run twice, like my autostart script that runs when I boot into exwm, for example, or setting =config-dir= to =user-emacs-directory=
#+begin_src emacs-lisp
(when (not (boundp 'has-restarted))
  (setq has-restarted nil))
#+end_src
** Mouse control for buffers
In EXWM, to use mouse hovering to change buffers, you have to set some variables prior to the =(package-intialize)= line in your config
#+begin_src emacs-lisp
(setq mouse-autoselect-window t
      focus-follows-mouse t)
#+end_src

** Make .emacs.d clean again!
I like to keep just the things I want in my user-emacs-directory, so I tell emacs to put everything except the stuff I want in a different spot
#+begin_src emacs-lisp
(when (not has-restarted)
  (setq config-dir user-emacs-directory)) ;; to use for some stuff like autostart.sh for example, which I do want in my default user-emacs-directory
(setq user-emacs-directory "~/.cache/emacs/")
#+end_src

** Package choices
I like to use emacs in lots of different contexts, and certain things like EXWM aren't exactly needed for the computer I have to use in my comp sci class.
#+begin_src emacs-lisp
(setq

 ;; packages
 packages/evil t ;; evil mode. Setting to nil breaks all SPC- keybdings
 packages/doom-modeline t ;; doom emacs modeline
 packages/spaceline nil ;; spacemacs modeline
 packages/tabs t ;; centaur tabs
 packages/dashboard t ;; dashboard
 packages/autocompletion t ;; code autocompletion. think company, lsp
 packages/treemacs t ;; a file viewer like nerdtree for vim
 packages/projectile t ;; a project manager for emacs
 packages/perspectives t ;; workspaces for emacs
 packages/snippets t ;; code snippets, because my hand are too weak

 ;; language support
 langs/web nil ;; html, js, css
 langs/java t ;; java
 langs/haskell nil ;; haskell

 ;; The Emacs Operating System
 emacsOS/run-launcher t ;; a run launcher like dmenu or rofi
 emacsOS/exwm t ;; an emacs window manager
 emacsOS/elfeed nil ;; an rss feed for emacs
 emacsOS/emms t ;; a music player for emacs
 emacsOS/vterm t ;; a fully featured terminal inside of emacs
 emacsOS/calendar t ;; a nice looking calendar
 emacsOS/mail t ;; a mail client inside of emacs
)
#+end_src

* Package setup
** Melpa
Melpa is a repository for emacs that enables a lot more than what is in the standard elpa repos
#+begin_src emacs-lisp
(require 'package)
(setq package-user-dir (concat user-emacs-directory ".local/elpa"))
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)
#+end_src

** use-package
This is no longer needed, since Emacs 29 has use-package built in
#+begin_src emacs-lisp
										;(unless (package-installed-p 'use-package)
										;(package-refresh-contents)
										;(package-install 'use-package))
										;(setq use-package-always-ensure t)
#+end_src

** Custom Package Management
A simple function that'll download a package and load it for you from github
#+begin_src emacs-lisp
(defun bugger/extern-package (AUTHOR PACKAGE)
  "Installs an emacs package from the github link https://github.com/AUTHOR/PACKAGE"

  ;; create the installation directory if it doesn't exist
  (when  (not (file-exists-p (concat user-emacs-directory ".local/extern-package")))
	(mkdir (concat user-emacs-directory ".local/extern-package")))

  ;; clone the project if it doesn't exist
  (when (not (file-exists-p (concat user-emacs-directory ".local/extern-package/" PACKAGE)))
	(shell-command (concat "git clone https://github.com/" AUTHOR "/" PACKAGE " " user-emacs-directory ".local/extern-package/" PACKAGE)))

  ;; load the package
  (add-to-list 'load-path (concat user-emacs-directory ".local/extern-package/" PACKAGE))
  (require (intern (symbol-value 'PACKAGE))))
#+end_src
* Evil
Evil is a vim emulation package for emacs, the Emacs Vi extension Layer
#+begin_src emacs-lisp
(require 'bind-key)
(when packages/evil
  (use-package evil
	:ensure t
	:init
	(setq evil-want-keybinding nil)
	:config
	(evil-mode 1)
	(evil-set-undo-system 'undo-redo)))
#+end_src

add evil in every buffer
#+begin_src emacs-lisp
(when packages/evil
  (use-package evil-collection
	:ensure t
	:after evil magit
	:config
	(evil-collection-init)))
#+end_src

* UX
** Fonts
#+begin_src emacs-lisp
;; (add-to-list 'default-frame-alist
;;              '(font . "AnonymicePro Nerd Font Mono-15"))
(use-package treemacs-icons-dired
  :ensure t
  :hook (dired-mode . treemacs-icons-dired-mode))
#+end_src

** Indent guides
#+begin_src emacs-lisp
(use-package highlight-indent-guides
  :defer t
  :ensure t
  :hook (prog-mode . highlight-indent-guides-mode))
(add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
(setq highlight-indent-guides-method 'character)
#+end_src

** Theme
#+begin_src emacs-lisp
(use-package doom-themes
  :ensure t
  :config
  (load-theme 'doom-one t))
;; (use-package xresources-theme
;;   :ensure t)
;; (add-hook 'server-after-make-frame-hook #'(lambda ()
;; 											(interactive)
;; 											(load-theme 'xresources t)))
#+end_src

** Icons
#+begin_src emacs-lisp
(use-package all-the-icons
  :ensure t
  :after exwm) ;; this line needs to be fixed for when exwm is disabled
#+end_src

** Modeline
A nice little bar at the bottom
There are two main choices to make the modeline better: Doom modeline and Spaceline, developed for the doom emacs and spacemacs projects, respectively. It's really a matter of preference
*** Doom Modeline
#+begin_src emacs-lisp
(when packages/doom-modeline
  (use-package doom-modeline
	:after all-the-icons
	:ensure t
	:hook (after-init . doom-modeline-mode)
	:hook (doom-modeline-mode . size-indication-mode)
	:hook (doom-modeline-mode . column-number-mode)

	:config
	(setq projectile-dynamic-mode-line t)

	;; Set these early so they don't trigger variable watchers
	(setq doom-modeline-bar-width 3
          doom-modeline-github nil
          doom-modeline-mu4e t
          doom-modeline-persp-name t
          doom-modeline-minor-modes nil
          doom-modeline-major-mode-icon t
          doom-modeline-buffer-file-name-style 'filename
          ;; Only show file encoding if it's non-UTF-8 and different line endings
          ;; than the current OSes preference
          doom-modeline-buffer-encoding 'nondefault
          doom-modeline-default-eol-type 0
          doom-modeline-height 35
		  doom-modeline-icon t)
	
	(when (package-installed-p 'ef-themes)
	  (add-hook 'ef-themes-post-load-hook #'doom-modeline-refresh-bars))))

(when (file-exists-p "/sys/class/power_supply/")
  (display-battery-mode 1))
#+end_src

*** Spaceline
**** Dependencies for spaceline
#+begin_src emacs-lisp
(when packages/spaceline
  (use-package fancy-battery
	:ensure t
	:config
	(fancy-battery-mode)))
#+end_src

**** The actual bar
#+begin_src emacs-lisp
(when packages/spaceline
  (use-package spaceline
	:ensure t
	:config
	(require 'spaceline-config)
	(setq powerline-default-seperator (quote arrow)
		  powerline-height 25)
	(spaceline-toggle-minor-modes-off)
	(spaceline-toggle-version-control-on)
	(spaceline-toggle-battery)
	(spaceline-toggle-flycheck-info-on)
	(spaceline-toggle-global)
	(spaceline-toggle-hud-off)
	(spaceline-toggle-mu4e-alert-segment-on)
	(spaceline-spacemacs-theme)

	;; emms support
	(spaceline-define-segment all-the-icons-track
	  "Show the current played track"
	  (emms-mode-line-icon-function))))
#+end_src
** Centaur tabs
Centaur tabs is a better tab bar for emacs
#+begin_src emacs-lisp
(when packages/tabs
  (use-package centaur-tabs
	:ensure t
	:hook (server-after-make-frame . centaur-tabs-mode)
	:init
	(setq centaur-tabs-set-icons t
		  centaur-tabs-gray-out-icons 'buffer
		  centaur-tabs-set-bar 'left
		  centaur-tabs-set-modified-marker t
		  centaur-tabs-close-button "✕"
		  centaur-tabs-modified-marker "•"
		  ;; Scrolling (with the mouse wheel) past the end of the tab list
		  ;; replaces the tab list with that of another Doom workspace. This
		  ;; prevents that.
		  centaur-tabs-cycle-scope 'tabs)))
#+end_src
    
** Line numbers
#+begin_src emacs-lisp
(global-display-line-numbers-mode 1)
#+end_src

** Highlight the line
#+begin_src emacs-lisp
(global-hl-line-mode)
#+end_src

** Rid of ugly stuff
#+begin_src emacs-lisp
(tool-bar-mode -1)
(scroll-bar-mode -1)
(menu-bar-mode -1)
#+end_src

** Scrolling
#+begin_src emacs-lisp
;; scroll one line at a time (less "jumpy" than defaults)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; 2 lines at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
(setq scroll-step 1) ;; keyboard scroll one line at a time
(setq scroll-conservatively 101) ;; scroll one line at a time when moving the cursor down the page
(pixel-scroll-precision-mode 1) ;; smooth scrolling
#+end_src

** Dashboard
*** Dependencies
Nice little lines
#+begin_src emacs-lisp
(when packages/dashboard
  (use-package page-break-lines
	:ensure t
	:config (global-page-break-lines-mode)))
#+end_src

Get rid of agenda files from the recentf list
#+begin_src emacs-lisp
(when packages/dashboard
  (use-package recentf
	:ensure t
	:config
	(add-to-list 'recentf-exclude "~/org/agenda/schedule.org")
	(add-to-list 'recentf-exclude "~/org/agenda/todo.org")
	(add-to-list 'recentf-exclude "~/org/agenda/emacs.org")
	(add-to-list 'recentf-exclude "~/org/agenda/homework.org")
	(add-to-list 'recentf-exclude (concat user-emacs-directory "bookmarks"))
	:hook (dashboard . display-line-numbers-mode)))
#+end_src

*** The actual dashboard
A dashboard inside of emacs
#+begin_src emacs-lisp
(when packages/dashboard
  (use-package dashboard
	:after all-the-icons
	:after page-break-lines
	:after projectile
	:after recentf
	:ensure t
	:init
	(setq initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
	(setq dashboard-items '((recents . 5)
							(projects . 5)
							(agenda . 5)))
	(setq dashboard-icon-type 'all-the-icons)
	(setq dashboard-center-content t)
	(setq dashboard-set-heading-icons t)
	(setq dashboard-set-file-icons t)
	:config
	(dashboard-setup-startup-hook)))
#+end_src

** Rainbows!
Adds rainbow parentheses and color to hex values and such
#+begin_src emacs-lisp
(use-package rainbow-mode
  :ensure t
  :hook (prog-mode . (lambda () (interactive) (rainbow-mode 1))))
(use-package rainbow-delimiters
  :ensure t
  :hook (prog-mode . (lambda () (interactive) (rainbow-delimiters-mode 1))))
(use-package rainbow-identifiers
  :ensure t
  :hook (prog-mode . (lambda () (interactive) (rainbow-identifiers-mode 1))))
#+end_src

** Window transparency
Another new feature in Emacs 29 that lets you make the background transparent while keeping text and such solid
#+begin_src emacs-lisp
;; (add-to-list 'default-frame-alist '(alpha-background . 85))
#+end_src

** Tree Sitter
Tree sitter is now built into emacs as of Emacs 29
#+begin_src emacs-lisp
(when langs/java
  (add-hook 'java-mode-hook 'java-ts-mode))
#+end_src
** Visual Line Mode
#+begin_src emacs-lisp
(global-visual-line-mode 1)
#+end_src
* Org mode
Org mode is an extremely helpful tool that allows you to do anything from writing scientific papers, take notes, even write entire programs!
** Org tempo
A simple tool that simplifies writing source code blocks to just typing <s TAB, as well as other similar functions
#+begin_src emacs-lisp
(use-package org-tempo
  :ensure nil)
#+end_src

** Auto tangle
Tangle a file to its source code blocks automatically upon save
#+begin_src emacs-lisp
(use-package org-auto-tangle
  :ensure t
  :defer t
  :hook (org-mode . org-auto-tangle-mode))
#+end_src

** Indentation
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'org-indent-mode)
(setq org-hide-leading-stars nil)
#+end_src

** Toc-org
This automatically generates a table of contents under any heading tagged :TOC:
#+begin_src emacs-lisp
(use-package toc-org
  :hook (org-mode . toc-org-mode))
#+end_src
** Babel settings
#+begin_src emacs-lisp
(setq org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-confirm-babel-evaluate nil
      org-src-window-setup 'current-window
      org-src-preserve-indentation t)
#+end_src

** Org agenda
Org agenda is a full blown scheduling application with all the power of org mode built into it
#+begin_src emacs-lisp
(setq org-agenda-files (list "~/org/agenda/todo.org"
                             "~/org/agenda/homework.org"
                             "~/org/agenda/emacs.org"
                             "~/org/agenda/schedule.org"))
#+end_src

* Nice Packages and Settings
Things that aren't really necessary to do stuff, but nice to have
** Keeping emacs clean
Some things \*cough cough auto-save-list\* don't like to cooperate with the settings I put earlier, so I use the no-littering package to fix that
#+begin_src emacs-lisp
(use-package no-littering
  :ensure t)
#+end_src
** Smartparens
Auto completes (, [, {, ", etc for you so you don't have to keep track of them
#+begin_src emacs-lisp
(use-package smartparens
  :ensure t
  :config
  (require 'smartparens-config)
  (smartparens-global-mode 1))
#+end_src

** Ivy
Ivy is a minibuffer autocompletion framework that makes it a lot easier to do things like input commands
*** Just ivy
#+begin_src emacs-lisp
(use-package ivy
  :defer 0.1
  :diminish
  :custom
  (setq ivy-count-format "(%d/%d) ")
  (setq ivy-use-virtual-buffers t)
  (setq enable-recursive-minibuffers t)
  :config
  (ivy-mode)
  :hook (ivy-mode . (lambda ()
					  (interactive)
					  (define-key ivy-mode-map (kbd "DEL") 'ivy-backward-delete-char))))
#+end_src

*** Counsel
Counsel a sort of extension to ivy, taking lots of functions already in emacs and putting them into an ivy completion minibuffer
#+begin_src emacs-lisp
(use-package counsel
  :after ivy
  :config
  (counsel-mode)
  (setq ivy-initial-inputs-alist nil)) ; Disable the "^" in interactive counsel commands like M-x
#+end_src

*** Ivy-rich
Gives us keybindings alongside the commands they go with when in an ivy completion minibuffer
#+begin_src emacs-lisp
(use-package ivy-rich
  :after ivy
  :ensure t
  :defer t
  :custom
  (ivy-virtual-abbreviate 'full
						  ivy-rich-switch-buffer-align-virtual-buffer t
						  ivy-rich-path-style 'abbrev)
  :config
  (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
  (ivy-rich-mode 1))
#+end_src

*** Swiper
A better way to search
#+begin_src emacs-lisp
(use-package swiper
  :after ivy
  :defer t
  :bind (:map evil-normal-state-map
			  ("/" . swiper-isearch)
			  ("n" . evil-search-previous)
			  ("N" . evil-search-next)))
#+end_src

** Tabbing
#+begin_src emacs-lisp
(setq indent-tabs-mode t)
(setq-default tab-width 4
              c-basic-offset 4
              c-default-style "stroustrup")
(defvaralias 'c-basic-offset 'tab-width)
#+end_src

** Visual lines
#+begin_src emacs-lisp
(define-key evil-normal-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
(define-key evil-normal-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
(define-key evil-motion-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
(define-key evil-motion-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
#+end_src

** Too lazy to type yes
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

** Too lazy to type ESC-ESC-ESC or C-g
#+begin_src emacs-lisp
(global-set-key (kbd "<escape>") 'abort-minibuffers)
#+end_src

** Autocompletion
Emacs has support for code autocompletion on par with that of IDEs like VSCode or IntelliJ
*** Company
Company is the package that enables the little popup for autocompletion so you don't to invoke a keybind or anything
#+begin_src emacs-lisp
(when packages/autocompletion
  (use-package company
	:defer t
	:ensure t
	:config
	(global-company-mode)))
#+end_src
*** LSP
LSP is the Language Server Protocol, and is what actually populates the company frame with suggestions
#+begin_src emacs-lisp
(when packages/autocompletion
  (use-package lsp-mode
	:ensure t
	:defer t
	:hook (prog-mode . #'lsp-deferred)
	:config
	(setq lsp-keymap-prefix "C-l"))

										; extensions
  (when langs/haskell
	(use-package lsp-haskell
	  :ensure t
	  :defer t
	  :after lsp-mode))

  (when packages/treemacs
	(use-package lsp-treemacs
	  :ensure t
	  :defer t
	  :after lsp-mode))

  (when langs/java
	(use-package lsp-java
	  :ensure t
	  :defer t
	  :after lsp-mode))

  (use-package lsp-ui
	:ensure t
	:defer t
	:after lsp-mode
	:hook (lsp-mode . lsp-ui-doc-mode)))
#+end_src

** Flycheck
Flycheck is a program that enables essentially 'spell checking' your code
#+begin_src emacs-lisp
(use-package flycheck
  :defer t
  :ensure t
  :config
  (global-flycheck-mode))
#+end_src
** Treemacs
Treemacs is a little side panel that shows a directory tree
#+begin_src emacs-lisp
(when packages/treemacs
  (use-package treemacs
	:ensure t
	:defer t)
  (when packages/evil
	(use-package treemacs-evil
	  :ensure t
	  :after (treemacs evil)))
  (when packages/projectile
	(use-package treemacs-projectile
	  :ensure t
	  :after (treemacs projectile)))
  (use-package treemacs-magit
	:ensure t
	:after (treemacs magit))
  (use-package treemacs-all-the-icons
	:ensure t
	:after (treemacs all-the-icons)))
#+end_src
** Projectile
Projectile manages projects
#+begin_src emacs-lisp
(when packages/projectile
  (use-package projectile
	:ensure t
	:config
	(projectile-mode +1))

  (use-package projectile-ripgrep
	:ensure t
	:after projectile)

  (use-package counsel-projectile
	:ensure t
	:after (projectile counsel)))
#+end_src

** Perspectives
Like workspaces inside of emacs to clean up the buffer list
#+begin_src emacs-lisp
(when packages/perspectives
  (use-package perspective
	:ensure t
	:config
	(setq persp-mode-prefix-key "C-x x")
	(persp-mode)))
#+end_src
*** Projectile integration
It'd be really nice if you could assign perspectives to projects, right? It is, so I did that.
#+begin_src emacs-lisp
(when (and packages/perspectives packages/projectile)
(use-package persp-projectile
  :ensure t
  :after perspective
  :after projectile))
#+end_src
** YASnippet
YASnippet is a templating system for emacs that allows you to type whatever you want, that expands into whatever you want.
*** Main Install
#+begin_src emacs-lisp
(when packages/snippets
  (use-package yasnippet
	:ensure t
	:config
	(setq yas-snippet-dirs (list (concat user-emacs-directory "snippets")))
	(yas-global-mode 1)))
#+end_src

*** Extra Snippets
#+begin_src emacs-lisp
(when packages/snippets
  (use-package yasnippet-snippets
	:ensure t
	:after yasnippet)
  (when langs/java
	(use-package java-snippets
	  :ensure t
	  :after yasnippet)))
#+end_src
** Web mode
Support for web development with web-mode and emmet-mode
#+begin_src emacs-lisp
(when langs/web
  (use-package web-mode
	:ensure t
	:init
	(add-to-list 'auto-mode-alist  '("\\.html$" . web-mode))
	(add-to-list 'auto-mode-alist  '("\\.css?\\'" . web-mode))
	(add-to-list 'auto-mode-alist  '("\\.js$\\'" . web-mode)))
  (use-package emmet-mode
	:ensure t
	:after web-mode
	:hook (web-mode . emmet-mode)))
#+end_src

** Commenting
Neat package that gives some nice commenting functions
#+begin_src emacs-lisp
(use-package evil-nerd-commenter :ensure t)
#+end_src
** Dired
Dired has some nice extensions that let you automatically open in another program, and preview files
#+begin_src emacs-lisp
(use-package dired-open
  :ensure t
  :after dired
  :config
  (setq dired-open-extensions '(("gif" . "nsxiv")
								("jpg" . "nsxiv")
								("png" . "nsxiv")
								("mkv" . "mpv")
								("mp4" . "mpv")
								("mp3" . "mpv"))))
(use-package peep-dired
  :after dired
  :ensure t
  :hook (peep-dired . evil-normalize-keymaps)
  :config
  (evil-define-key 'normal dired-mode-map (kbd "h") 'dired-up-directory)
  (evil-define-key 'normal dired-mode-map (kbd "j") 'peep-dired-next-file)
  (evil-define-key 'normal peep-dired-mode-map (kbd "k") 'peep-dired-prev-file)
  (evil-define-key 'normal peep-dired-mode-map (kbd "l") 'dired-open-file))


#+end_src
** Auto Backup
Emacs has a feature to automatically back up files every so often, which is nice, but clogs up the directory and git, so I moved it
#+begin_src emacs-lisp
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))
#+end_src
** Undo
#+begin_src emacs-lisp
(setq evil-undo-system 'undo-redo)
#+end_src
* Emacs as an Operating System
The packages that let me use emacs instead of some external package
** App Launcher
An emacs replacement for dmenu. Should only be used outside of exwm
#+begin_src emacs-lisp
(when emacsOS/run-launcher
  (bugger/extern-package "SebastienWae" "app-launcher")

  ;; create a global keyboard shortcut with the following code
  ;; emacsclient -cF "((visibility . nil))" -e "(emacs-run-launcher)"
  (defun emacs-run-launcher ()
	"Create and select a frame called emacs-run-launcher which consists only of a
minibuffer and has specific dimensions. Runs app-launcher-run-app on that frame,
 which is an emacs command that prompts you to select an app and open it in a
 dmenu like behaviour. Delete the frame after that command has exited"
	(interactive)
	(with-selected-frame 
		(make-frame '((name . "emacs-run-launcher")
					  ;; (minibuffer . only)
					  (fullscreen . 0) ; no fullscreen
					  (undecorated . t) ; remove title bar
					  ;; (auto-raise . t) ; focus on this frame
					  ;; (tool-bar-lines . 0)
					  ;; (menu-bar-lines . 0)
					  (internal-border-width . 10)
					  (width . 80)
					  (height . 15)))
      (unwind-protect
		  (funcall (lambda ()
					 (interactive)
					 (centaur-tabs-local-mode)
					 (app-launcher-run-app)
					 (centaur-tabs-local-mode)))
		(delete-frame)))))
#+end_src
** EXWM
The Emacs X Window Manager is a project that replaces your entire desktop management system with emacs
*** EXWM Keybindings
#+begin_src emacs-lisp
(when emacsOS/exwm
  (defun bugger/keybindings ()
	;; These keys should always pass through to Emacs
	(setq exwm-input-prefix-keys
          '(?\C-x
			?\C-u
			?\C-h
			?\M-x
			?\M-`
			?\M-&
			?\M-:
			?\C-\M-j  ;; Buffer list
			?\C-\ ))  ;; Ctrl+Space

	;; Ctrl+Q will enable the next key to be sent directly
	(define-key exwm-mode-map (kbd "C-q") 'exwm-input-send-next-key)

	;; simulation keys. if you press one keybinding, it'll send the corresponding one to whatever application you have open
	(setq exwm-input-simulation-keys
		  '(([?\C-c ?\C-c] . ?\C-c)
			([?\C-n] . [down])
			([?\C-p] . [up])
			([?\C-f] . [right])
			([?\C-b] . [left])))

	;; Set up global key bindings.  These always work, no matter the input state!
	;; Keep in mind that changing this list after EXWM initializes has no effect.
	(setq exwm-input-global-keys
          `(
			;; Reset to line-mode (C-c C-k switches to char-mode via exwm-input-release-keyboard)
			(,(kbd "s-r") . exwm-reset)

			;; exit
			(,(kbd "s-C-q") . (lambda ()
								(interactive)
								(start-process-shell-command "killall emacs" nil "killall emacs")))

			;; app launcher
			(,(kbd "s-p") . app-launcher-run-app)

			;; emacs keys to move between windows
			(,(kbd "s-h") . windmove-left)
			(,(kbd "s-l") . windmove-right)
			(,(kbd "s-k") . windmove-up)
			(,(kbd "s-j") . windmove-down)

			;; vim keys to swap windows
			(,(kbd "C-s-h") . windmove-swap-states-left)
			(,(kbd "C-s-l") . windmove-swap-states-right)
			(,(kbd "C-s-k") . windmove-swap-states-up)
			(,(kbd "C-s-j") . windmove-swap-states-down)

			;; terminal
			(,(kbd "s-<return>") . vterm-other-window)

			;; Launch applications via shell command
			(,(kbd "C-s-7") . (lambda (command)
								(interactive (list (read-shell-command "$ ")))
								(start-process-shell-command command nil command)))
			
			;; music
			(,(kbd "<XF86AudioRaiseVolume>") . (lambda ()
												 (interactive)
												 (start-process-shell-command
                                                  "volume-raise"
                                                  nil
                                                  "snd up")))
			(,(kbd "<XF86AudioLowerVolume>") . (lambda ()
												 (interactive)
												 (start-process-shell-command
                                                  "volume-lower"
                                                  nil
                                                  "snd down")))
			(,(kbd "C-c m l") . emms-next)
			(,(kbd "C-c m h") . emms-previous)
			(,(kbd "C-c m p") . emms-pause)
			(,(kbd "C-c m r") . emms-player-mpd-update-all-reset-cache)

			;; vterm
			(,(kbd "C-c v") . vterm-toggle)

			;; eshell
			(,(kbd "C-c e") . (lambda ()
								(interactive)
								(split-window-right)
								(eshell)))

			;; create an emacs window
			(,(kbd "s-e") . (lambda ()
							  (interactive)
							  (split-window-right)))

			;; brightness
			(,(kbd "<XF86MonBrightnessUp>") . (lambda ()
												(interactive)
												(start-process-shell-command
												 "volume-raise"
												 nil
												 "real-brightness up")))
			(,(kbd "<XF86MonBrightnessDown>") . (lambda ()
                                                  (interactive)
                                                  (start-process-shell-command
                                                   "volume-lower"
                                                   nil
                                                   "real-brightness down")))
			;; layout stuff
			(,(kbd "s-m") . exwm-layout-toggle-fullscreen)
			(,(kbd "s-f") . exwm-floating-toggle-floating)

			;; Switch workspace
			(,(kbd "s-w") . exwm-workspace-switch)

			;; 's-N': Switch to certain workspace with Super (Win) plus a number key (0 - 9)
			,@(mapcar (lambda (i)
						`(,(kbd (format "s-%d" i)) .
                          (lambda ()
							(interactive)
							(exwm-workspace-switch-create ,(- i 1)))))
                      (number-sequence 1 9))
			(,(kbd "s-0") . (lambda ()
							  (interactive)
							  (exwm-workspace-switch-create 9)))))))
#+end_src

*** GPG 
GPG Pinentry kinda broken in EXWM so you gotta fix it
#+begin_src emacs-lisp
(when emacsOS/exwm
  (defun bugger/gpg-fix ()
	(use-package pinentry
      :ensure t
	  :config
	  (setenv "GPG_AGENT_INFO" nil)
	  (setq auth-source-debug t)

	  (setq epg-gpg-program "gpg2")
	  (require 'epa-file)
	  (epa-file-enable)
	  (setq epg-pinentry-mode 'loopback)
	  (pinentry-start))

	(require 'org-crypt)
	(org-crypt-use-before-save-magic)))
#+end_src

To fully fix, you have to append the following to =~/.gnupg/gpg-agent.conf=
#+begin_example
allow-emacs-pinentry
allow-loopback-pinentry
#+end_example

*** Settings
#+begin_src emacs-lisp
;; function for renaming windows
(when emacsOS/exwm
  (defun exwm-rename-buffer ()
	(interactive)
	(exwm-workspace-rename-buffer exwm-class-name))

  (defun bugger/exwm-settings ()
	(setq exwm-workspace-number 10) ;; setting workspaces

	;; systray
	;; (use-package exwm-systemtray
	;;   :config
	;;   (exwm-systemtray-enable))

	;; set window names
	(add-hook 'exwm-update-class-hook 'exwm-rename-buffer)
	(add-hook 'exwm-update-title-hook 'exwm-rename-buffer)))
#+end_src
*** Autostart
#+begin_src emacs-lisp
(when emacsOS/exwm
  (defun bugger/autostart ()
	(call-process "/bin/sh" (concat config-dir "autostart.sh"))))
#+end_src
*** Main
Where it all ties together
#+begin_src emacs-lisp
(when emacsOS/exwm
  (use-package exwm
	:ensure t
	:config
	(bugger/exwm-settings)
	(bugger/gpg-fix)
	(bugger/keybindings)

	(exwm-enable)

	(when (not has-restarted)
	  (bugger/autostart))))
#+end_src
** Elfeed
An RSS Client for emacs
#+begin_src emacs-lisp
(when emacsOS/elfeed
  (use-package elfeed
	:ensure t)
  (use-package elfeed-org
	:ensure t
	:after elfeed
	:config
	(elfeed-org))
  (use-package elfeed-goodies
	:ensure t
	:after elfeed
	:config
	(elfeed-goodies/setup)))
#+end_src
** Vterm
Vterm is a fully fledged terminal within emacs
#+begin_src emacs-lisp
(when emacsOS/vterm
  (use-package vterm
	:defer t
	:ensure t
	:config
	(setq shell-file-name "/bin/zsh"
		  vterm-max-scrollback 5000)))
#+end_src
*** Toggling
It's kind of annoying to have an ordinary window stuck there at the bottom that you have to deal with and pop back up to reconfigure the window again, so why not add a toggle for it?
#+begin_src emacs-lisp
(when emacsOS/vterm
  (use-package vterm-toggle
	:after vterm
	:ensure t
	:config
	(setq vterm-toggle-fullscreen-p nil)
	(setq vterm-toggle-scope 'project)
	(add-to-list 'display-buffer-alist
				 '((lambda (buffer-or-name _)
					 (let ((buffer (get-buffer buffer-or-name)))
                       (with-current-buffer buffer
						 (or (equal major-mode 'vterm-mode)
							 (string-prefix-p vterm-buffer-name (buffer-name buffer))))))
                   (display-buffer-reuse-window display-buffer-at-bottom)
                   ;;(display-buffer-reuse-window display-buffer-in-direction)
                   ;;display-buffer-in-direction/direction/dedicated is added in emacs27
                   ;;(direction . bottom)
                   ;;(dedicated . t) ;dedicated is supported in emacs27
                   (reusable-frames . visible)
                   (window-height . 0.3)))))
#+end_src
** EMMS
The Emacs Multimedia System lets you use emacs as a music player
#+begin_src emacs-lisp
(when emacsOS/emms
  (use-package emms
	:ensure t
	:after exwm ;; exwm autostart is where mpd gets started
	:config
	(require 'emms-setup)
	(require 'emms-player-mpd)
	(emms-all)
	(setq emms-seek-seconds 5)
	(setq emms-player-list '(emms-player-mpd))
	(setq emms-info-functions '(emms-info-mpd))
	(setq emms-player-mpd-music-directory (concat (getenv "HOME") "/Music"))
	(setq emms-player-mpd-server-name "localhost")
	(setq emms-player-mpd-server-port "6600")
	(setq mpc-host "localhost:6600")))
#+end_src

** Calfw
A calendar within emacs!
#+begin_src emacs-lisp
(when emacsOS/calendar
  (use-package calfw
	:ensure t)
  (use-package calfw-org
	:ensure
	:after calfw))
#+end_src

** MU4E
Maildir Utils 4 Emacs, an email client for emacs
#+begin_src emacs-lisp
(when emacsOS/mail
  (use-package mu4e
	:ensure nil
	:load-path "/usr/share/emacs/site-lisp/mu4e"
	:config
	(setq smtpmail-stream-type 'starttls
          mu4e-change-filenames-when-moving t
		  mu4e-update-interval (* 10 60)
		  mu4e-compose-format-flowed t
		  mu4e-hide-index-messages t ;; stop flashing my email to everyone around me
		  mu4e-get-mail-command "mbsync -a" ;; requires isync to be installed and configured for your emails
		  ;; NOTE: I recommend using .authinfo.gpg to store an encrypted set of your email usernames and passwords that mbsync pulls from
		  ;; using the decryption function defined below
		  message-send-mail-function 'smtpmail-send-it)

	;; this is a dummy configuration for example
	;; my real email info is stored in ~/.cache/emacs/emails.el

	;; mu4e-contexts (list
	;; 			   (make-mu4e-context
	;; 				:name "My email"
	;; 				:match-func (lambda (msg)
	;; 							  (when msg
	;; 								(string-prefix-p "/Gmail" (mu4e-message-field msg :maildir))))
	;; 				:vars '((user-mail-address . "myemail@gmail.com")
	;; 						(user-full-name    . "My Name")
	;; 						(smtpmail-smtp-server . "smtp.gmail.com")
	;; 						(smtpmail-smtp-service . 587) ;; this is for tls, use 465 for ssl, 25 for plain
	;; 						(mu4e-drafts-folder . "/[Gmail]/Drafts")
	;; 						(mu4e-sent-folder . "/[Gmail]/Sent Mail")
	;; 						(mu4e-refile-folder . "/[Gmail]/All Mail")
	;; 						(mu4e-trash-folder . "/[Gmail]/Trash"))))

	(load (concat user-emacs-directory "emails.el"))))
#+end_src

*** MU4E Alert
A good package to get notifications when emails come in, as well as a good modeline display for emails
#+begin_src emacs-lisp
(use-package mu4e-alert
  :after mu4e
  :ensure t
  :config
  (mu4e-alert-enable-mode-line-display)
  (mu4e-alert-enable-notifications))
#+end_src
** Password Encryption
#+begin_src emacs-lisp
(defun efs/lookup-password (&rest keys)
  (let ((result (apply #'auth-source-search keys)))
	(if result
		(funcall (plist-get (car result) :secret))
	  nil)))
#+end_src
* Keybindings
** Nice little things
#+begin_src emacs-lisp
;; tab over the region
(when packages/evil
  (define-key evil-visual-state-map (kbd "TAB") 'indent-region)

  ;; comment/uncomment the region
  (define-key evil-visual-state-map (kbd "C-/") 'evilnc-comment-or-uncomment-lines)
  (define-key evil-normal-state-map (kbd "C-/") 'evilnc-comment-or-uncomment-lines)

  ;; toggle tolding
  (define-key evil-normal-state-map (kbd "TAB") 'evil-toggle-fold))

;; delete a tab, not 4 spaces
(global-set-key (kbd "DEL") 'backward-delete-char)
(setq c-backspace-function 'backward-delete-char)
#+end_src

** General
General is a package that allows us to do very complex things like bind space as a leader key, or add which-key labels to prefix keys
#+begin_src emacs-lisp
(when packages/evil
  (use-package general
	:ensure t
	:config (general-evil-setup t)))
#+end_src

** Which-key
Which-key displays possible completions for keybindings you have typed in a minibuffer at the bottom of the screen
#+begin_src emacs-lisp
(use-package which-key
  :ensure t
  :config (which-key-mode 1))
#+end_src

** Files
#+begin_src emacs-lisp
(when packages/evil
  (general-define-key
   :states '(normal visual)
   :prefix "SPC"
   "f"   '(:ignore t :which-key "files")
   "f s" '(save-buffer :which-key "Save file")
   "."   '(find-file   :which-key "open file"))
#+end_src

** Windows
#+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "w"   '(:ignore t              :which-key "windows")
 "w w" '(evil-window-next       :which-key "next window")
 "w v" '(evil-window-vsplit     :which-key "create new vertical window")
 "w n" '(evil-window-new        :which-key "create new window")
 "w q" '(evil-window-delete     :which-key "delete current window")
 "w k" '(kill-buffer-and-window :which-key "delete current window and buffer"))
#+end_src

** Buffers
#+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "b"   '(:ignore t                 :which-key "buffer")
 "b b" '(buffer-menu               :which-key "buffer menu")
 "b i" '(ibuffer                   :which-key "ibuffer")
 "b c" '(kill-this-buffer          :which-key "kill buffer")
 "b k" '(kill-this-buffer          :which-key "kill buffer")
 "b p" '(previous-buffer           :which-key "previous buffer")
 "b n" '(next-buffer               :which-key "next buffer")
 "b h" '(centaur-tabs-backward-tab :which-key "previous tab")
 "b l" '(centaur-tabs-forward-tab  :which-key "previous tab")
 "b r" '(revert-buffer             :which-key "reload buffer"))
(define-key evil-normal-state-map (kbd "q") #'(lambda ()
                                                (interactive)
                                                (when (buffer-modified-p)
                                                  (when (y-or-n-p "Buffer modified. Save?")
                                                    (save-buffer)))
                                                (kill-this-buffer)))
(define-key evil-normal-state-map (kbd "Q") #'(lambda ()
                                                (interactive)
                                                (when (buffer-modified-p)
                                                  (when (y-or-n-p "Buffer modified. Save?")
                                                    (save-buffer)))
                                                (kill-buffer-and-window)))
#+end_src

** Ibuffer
Add evil keybindings
#+begin_src emacs-lisp
(add-hook 'ibuffer-mode-hook #'(lambda ()
								 (interactive)
								 (keymap-local-set (kbd "l") 'ibuffer-visit-buffer)
								 (keymap-local-set (kbd "j") 'evil-next-visual-line)
								 (keymap-local-set (kbd "k") 'evil-previous-visual-line)))
#+end_src

** Dired
#+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "d" '(:ignore t :which-key "dired")
 "d d" '(dired :which-key "open dired")
 "d p" '(peep-dired :which-key "toggle peep-dired")
 "d j" '(dired-jump :which-key "open dired at current directory"))
(with-eval-after-load 'dired
  (evil-define-key 'normal dired-mode-map (kbd "h") 'dired-up-directory)
  (evil-define-key 'normal dired-mode-map (kbd "l") 'dired-open-file)) ; use dired-find-file if not using dired-open package
#+end_src

** Dashboard
#+begin_src emacs-lisp
(with-eval-after-load "evil"
  (add-hook 'dashboard-mode-hook #'(lambda ()
									 (interactive)
									 (evil-local-set-key 'normal (kbd "r") 'dashboard-jump-to-recents)
									 (evil-local-set-key 'normal (kbd "p") 'dashboard-jump-to-projects)
									 (evil-local-set-key 'normal (kbd "a") 'dashboard-jump-to-agenda)
									 (evil-local-set-key 'normal (kbd "l") 'dashboard-return)
									 (evil-local-set-key 'normal (kbd "e") #'(lambda ()
                                                                               (interactive)
                                                                               (find-file (concat config-dir "config.org"))))
									 (evil-local-set-key 'normal (kbd "x") #'(lambda ()
                                                                               (interactive)
                                                                               (find-file "~/.config/xmonad/xmonad.org"))))))
#+end_src

** Org agenda
#+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "o"     '(:ignore t :which-key "org")
 "o a"   '(:ignore t :which-key "org agenda")
 "o a c" '(cfw:open-org-calendar :which-key "open org calendar")
 "o C"   '(cfw:open-org-calendar :which-key "open org calendar")
 "o a a" '(org-agenda :which-key "open org agenda")
 "o a t" '(org-agenda-todo :which-key "open todo list"))
#+end_src

** Magit
#+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "g"   '(:ignore t :which-key "magit")
 "g g" '(magit :which-key "open magit")
 "g s" '(magit-status :which-key "status")
 "g b" '(magit-branch :which-key "branch")
 "g c o" '(magit-checkout :which-key "checkout")
 "g c b" '(magit-branch-and-checkout :which-key "create and checkout a branch")
 "g c c" '(magit-commit :which-key "commit")
 "g p l" '(magit-pull :which-key "pull")
 "g p s" '(magit-push :which-key "push"))
#+end_src

** Helpful functions
#+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "h" '(:ignore t :which-key "help")
 "h r" '(:ignore t :which-key "reload")
 "h v" '(describe-variable :which-key "describe variable")
 "h t" '(counsel-load-theme :which-key "load theme")
 "h f" '(describe-function :which-key "describe function"))
#+end_src

** Toggle
#+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "t" '(:ignore t :which-key "toggle")
 "t v" '(vterm-toggle :which-key "toggle vterm")
 "t c" '(company-mode :which-key "toggle company")
 "t l" '(lsp-mode :which-key "toggle lsp")
 "t w" '(visual-line-mode :which-key "toggle visual line mode"))
#+end_src

** Reload
#+begin_src emacs-lisp
(defun bugger/emacs-reload ()
  (interactive)
  (setq has-restarted t)
  (org-babel-tangle-file (concat config-dir "config.org"))
  (byte-compile-file (concat config-dir "init.el"))
  (load-file (concat config-dir "init.elc"))
  (load-file (concat config-dir "init.elc")))

(defun bugger/reload (mode)
  "Reload the mode specified by mode. mode must be a function"
  (funcall mode)
  (funcall mode))

(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "r" '(:ignore t :which-key "reload")
 "r r" '(bugger/emacs-reload :which-key "reload emacs")
 "r c" '(lambda () (interactive) (bugger/reload 'company-mode) :which-key "reload company")
 "r t" '(lambda () (interactive) (bugger/reload 'centaur-tabs-mode) :which-key "reload tabs")
 "r l" '(lambda () (interactive) (bugger/reload 'lsp-mode) :which-key "reload lsp"))

(which-key-add-key-based-replacements "SPC r c" "reload company")
(which-key-add-key-based-replacements "SPC r t" "reload tabs")
(which-key-add-key-based-replacements "SPC r l" "reload lsp")
#+end_src
** Projectile
#+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "/" '(counsel-projectile-rg :which-key "search project")
 "p" '(:ignore t :which-key "projectile")
 "p p" '(projectile-persp-switch-project :which-key "open project")
 "p c" '(projectile-compile-project :which-key "compile project")
 "p f" '(counsel-projectile-find-file-dwim :which-key "find file")
 "p a" '(projectile-add-known-project :which-key "add project"))
#+end_src

** YASnippet
#+begin_src emacs-lisp
(general-define-key
 :states '(normal visual)
 :prefix "SPC"
 "i" '(:ignore t :which-key "insert")
 "i s" '(yas-insert-snippet :which-key "snippets"))
(general-define-key
 :states 'insert
 :prefix "M-SPC"
 "i" '(:ignore t :which-key "insert")
 "i s" '(yas-insert-snippet :which-key "snippets"))
#+end_src
** EMMS
#+begin_src emacs-lisp
(general-define-key
 :prefix "SPC"
 :states '(normal visual)
 "m" '(:ignore t :which-key "music")
 "m m" '(emms :which-key "emms dashboard")
 "m n" '(emms-next :which-key "next song")
 "m p" '(emms-previous :which-key "prev song")
 "m r" '(emms-player-mpd-update-all-reset-cache :which-key "update database")
 "m b" '(emms-smart-browse :which-key "browse music")
 "m s" '(emms-shuffle :which-key "shuffle"))
#+end_src
** Perspective
s prefix doesn't make a lot of sense, but p for perspective and w for workspace
are taken already by projectile and windows respectively.
Just think of it like per*Spective*, or work*Space*
#+begin_src emacs-lisp
(general-define-key
 :prefix "SPC"
 :states '(normal visual)
 "s" '(:ignore t :which-key "persp")
 "s b" '(persp-counsel-switch-buffer :which-key "switch buffer")
 "s i" '(persp-ibuffer :which-key "persp ibuffer")
 "s s" '(persp-switch :which-key "switch perspective")
 "s n" '(persp-next :which-key "next perspective")
 "s p" '(persp-prev :which-key "prev perspective")
 "s a" '(persp-add-buffer :which-key "add buffer to perspesctive")
 "s A" '(persp-set-buffer :which-key "brgin buffer to perspective")
 "s r" '(persp-remove :which-key "remove buffer from perspective")
 "s k" '(persp-kill :which-key "kill perspective")
 "s K" '(persp-kill-others :which-key "kill other perspectives")))
#+end_src
* Clean up
Just need to put gc-cons-threshold back to a normal figure after init + start the server
#+begin_src emacs-lisp
(setq gc-cons-threshold (* 2 1024 1024))
(server-start)
#+end_src

